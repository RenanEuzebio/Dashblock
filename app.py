# app.py
from __future__ import annotations
import asyncio, json, os, re, socket, sys, threading, urllib.request
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from fabric import Connection
from litestar import Litestar, delete, get, post
from litestar.config.cors import CORSConfig
from litestar.exceptions import HTTPException

# ---- Windows loop compat ----
if sys.platform.startswith("win"):
    try: asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())  # type: ignore[attr-defined]
    except Exception: pass

# ---- SSH / VPS ----
SSH_KEY_PATH = Path("./ssh-key-2025-04-22.key")
SSH_USER, SSH_HOST, SSH_PORT = "opc", "79.76.126.31", 22

# ---- Proxy (this backend) ----
PUBLIC_HOST = os.getenv("PUBLIC_HOST", "127.0.0.1")
PROXY_BIND_HOST = os.getenv("PROXY_BIND_HOST", "0.0.0.0")
PROXY_PORT_START = int(os.getenv("PROXY_PORT_START", "26000"))

# ---- Layout / validation ----
DASHBLOCK_DIR, WORLDS_DIR = "dashblock", "dashblock/worlds"
SAFE_NAME  = re.compile(r"^[A-Za-z0-9._-]+$")
SAFE_VER   = re.compile(r"^[0-9]+(\.[0-9]+){1,2}$")
DEFAULT_SERVER_PROPERTIES = """# Generated by dashblock
motd=A Minecraft Server
online-mode=true
enable-command-block=false
allow-flight=false
max-players=20
difficulty=easy
gamemode=survival
view-distance=10
simulation-distance=10
white-list=false
server-port=25565
"""

# ---- Single persistent SSH connection (fast) ----
_conn_lock = threading.Lock()
_run_lock  = threading.Lock()
_conn_singleton: Optional[Connection] = None

def _conn() -> Connection:
    global _conn_singleton
    with _conn_lock:
        if _conn_singleton is None:
            if not SSH_KEY_PATH.exists():
                raise FileNotFoundError(f"SSH key not found: {SSH_KEY_PATH.resolve()}")
            _conn_singleton = Connection(
                host=SSH_HOST, user=SSH_USER, port=SSH_PORT,
                connect_timeout=15, connect_kwargs={"key_filename": str(SSH_KEY_PATH)}
            )
            _conn_singleton.open()
            try:
                t = _conn_singleton.client.get_transport()  # type: ignore[attr-defined]
                if t: t.set_keepalive(15)
            except Exception: pass
        return _conn_singleton

def _run(cmd: str) -> str:
    c = _conn()
    with _run_lock:
        r = c.run(f"/usr/bin/env bash -lc '{cmd}'", hide=True, warn=True)
    o, e = (r.stdout or "").strip(), (r.stderr or "").strip()
    if r.failed: raise RuntimeError(e or o or f"Command failed: {cmd}")
    return o

def _parse_bool(v) -> bool: return v if isinstance(v, bool) else str(v).lower() in ("1","true","yes","on")

# ---- Fabric meta (with short timeouts) ----
def get_game_versions() -> List[Dict[str, object]]:
    with urllib.request.urlopen("https://meta.fabricmc.net/v2/versions/game", timeout=12) as r:
        return json.load(r)

def resolve_loader_version(mc: str) -> str:
    with urllib.request.urlopen(f"https://meta.fabricmc.net/v2/versions/loader/{mc}", timeout=12) as r:
        d = json.load(r)
    if not d: raise RuntimeError(f"No Fabric loader for {mc}")
    return d[0]["loader"]["version"]

def resolve_installer_version() -> str:
    with urllib.request.urlopen("https://meta.fabricmc.net/v2/versions/installer", timeout=12) as r:
        d = json.load(r)
    v = d[0].get("version") if isinstance(d[0], dict) else str(d[0])
    if not v: raise RuntimeError("Bad installer version")
    return v

def compute_memory(gb: int) -> Tuple[str,str]:
    return f"{gb}G", f"{max(1, gb//2)}G"

# ---- Package helpers ----
def _have(cmd: str) -> bool:
    return _run(f"command -v {cmd} >/dev/null 2>&1 && echo yes || echo no") == "yes"

def detect_pkg_manager() -> Optional[str]:
    if _have("apt"): return "apt"
    if _have("dnf"): return "dnf"
    return None

def parse_java_pkg(pm: Optional[str], mc: str) -> str:
    maj, minor, patch = (int(x) for x in (mc.split(".")+["0","0"])[:3])
    use21 = (maj>1) or (maj==1 and (minor>20 or (minor==20 and patch>=5)))
    if pm=="apt": return "openjdk-21-jre-headless" if use21 else ("openjdk-8-jre-headless" if minor<=16 else "openjdk-17-jre-headless")
    if pm=="dnf": return "java-21-openjdk-headless" if use21 else ("java-1.8.0-openjdk-headless" if minor<=16 else "java-17-openjdk-headless")
    return "openjdk-17-jre-headless"

def install_prereqs(pm: Optional[str], java_pkg: str) -> None:
    if pm=="apt": _run("sudo apt-get update -y && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y curl ca-certificates " + java_pkg)
    elif pm=="dnf": _run("sudo dnf -y install curl ca-certificates " + java_pkg)

# ---- FS & world meta ----
def ensure_tree() -> None: _run(f'mkdir -p "$HOME/{WORLDS_DIR}"')
def bpath(name: str) -> str: return f'"$HOME/{WORLDS_DIR}/{name}"'

def ensure_world(name: str) -> None:
    if not SAFE_NAME.fullmatch(name): raise HTTPException(400, "Invalid world name.")
    _run(f'''
base={bpath(name)}; mkdir -p "$base/mods"
[ -f "$base/server.properties" ] || cat > "$base/server.properties" <<EOF
{DEFAULT_SERVER_PROPERTIES}
EOF
[ -f "$base/eula.txt" ] || echo "eula=false" > "$base/eula.txt"
''')

def read_props(name: str) -> Dict[str,str]:
    out = _run(f'if [ -f {bpath(name)}/server.properties ]; then grep -E "^[^#].*=.*" {bpath(name)}/server.properties || true; fi')
    d: Dict[str,str] = {}
    for ln in [x for x in out.splitlines() if x.strip()]:
        if "=" in ln: k,v = ln.split("=",1); d[k.strip()] = v.strip()
    return d

def write_props(name: str, cfg: Dict[str,str]) -> None:
    _run(f'cat > {bpath(name)}/server.properties <<EOF\n# Edited by dashblock\n' + "\n".join(f"{k}={cfg[k]}" for k in sorted(cfg)) + "\nEOF")

def list_mods(name: str) -> List[str]:
    out = _run(f'mkdir -p {bpath(name)}/mods; find {bpath(name)}/mods -maxdepth 1 -type f -printf "%f\n" || true')
    return [x for x in out.splitlines() if x]

def read_meta(name: str) -> Dict[str,str]:
    out = _run(f'if [ -f {bpath(name)}/world.json ]; then cat {bpath(name)}/world.json; else echo "{{}}"; fi')
    try: return json.loads(out or "{}") if isinstance(out,str) else {}
    except Exception: return {}

def write_meta(name: str, m: Dict[str,str]) -> None:
    _run(f'cd {bpath(name)} && cat > world.json <<EOF\n{json.dumps(m,separators=(",",":"))}\nEOF')

def delete_world(name: str) -> None: _run(f'rm -rf {bpath(name)}')

# ---- Ports ----
def read_port(name: str) -> int:
    try: return int(read_props(name).get("server-port","25565"))
    except Exception: return 25565

def port_busy(p: int) -> bool:
    try: return _run(f'timeout 1 bash -lc ": >/dev/tcp/127.0.0.1/{p} && echo yes || echo no"')=="yes"
    except Exception: return False

def free_port(start=25565, tries=1000) -> int:
    p = start
    for _ in range(tries):
        if not port_busy(p): return p
        p += 1
    raise RuntimeError("No free port found.")

def ensure_free_port(name: str) -> int:
    cfg = read_props(name)
    want = int(cfg.get("server-port","25565") or 25565)
    port = want if not port_busy(want) else free_port(max(25565,want))
    if str(port)!=cfg.get("server-port"): cfg["server-port"]=str(port); write_props(name,cfg)
    return port

# ---- Setup & lifecycle ----
def setup_fabric(name: str, mc: str, mem_gb: int, motd: str, online: bool) -> Dict[str,str]:
    if not SAFE_VER.fullmatch(mc): raise HTTPException(400,"mc_version must look like 1.20.1 or 1.21")
    if not (1<=mem_gb<=64): raise HTTPException(400,"mem_gb must be between 1 and 64")
    pm = detect_pkg_manager(); install_prereqs(pm, parse_java_pkg(pm, mc))
    loader, inst = resolve_loader_version(mc), resolve_installer_version()
    _run(f'cd {bpath(name)} && curl -fsSL "https://meta.fabricmc.net/v2/versions/loader/{mc}/{loader}/{inst}/server/jar" -o fabric-server-launch.jar && printf "eula=true\\n" > eula.txt')
    xmx,xms = compute_memory(mem_gb)
    _run(f'cd {bpath(name)} && cat > start.sh <<EOF\n#!/usr/bin/env bash\necho $$ > server.pid\nexec java -Xmx{xmx} -Xms{xms} -jar "fabric-server-launch.jar" nogui >> server.log 2>&1\nEOF\nchmod +x start.sh')
    cfg = read_props(name); cfg["motd"]=motd; cfg["online-mode"]="true" if online else "false"
    cfg["server-port"]=str(ensure_free_port(name)); write_props(name,cfg)
    meta={"mc_version":mc,"loader":loader,"installer":inst,"server_jar":"fabric-server-launch.jar","xmx":xmx,"xms":xms}; write_meta(name,meta)
    return {"port":int(cfg["server-port"]), **meta}

def update_settings(name: str, mem_gb: int, motd: str, online: bool) -> Dict[str,str]:
    xmx,xms=compute_memory(mem_gb)
    _run(f'cd {bpath(name)} && cat > start.sh <<EOF\n#!/usr/bin/env bash\necho $$ > server.pid\nSERVER_JAR="fabric-server-launch.jar"\nexec java -Xmx{xmx} -Xms{xms} -jar "$SERVER_JAR" nogui >> server.log 2>&1\nEOF\nchmod +x start.sh')
    cfg=read_props(name); cfg["motd"]=motd; cfg["online-mode"]="true" if online else "false"; write_props(name,cfg)
    meta=read_meta(name); meta.update({"xmx":xmx,"xms":xms}); write_meta(name,meta)
    return {"port":ensure_free_port(name),"xmx":xmx,"xms":xms}

def start_world(name: str) -> Tuple[str,int]:
    port=ensure_free_port(name)
    pid=_run(f'cd {bpath(name)} && : > server.log || true; nohup ./start.sh >/dev/null 2>&1 & '
             f'for i in $(seq 1 50); do [ -s server.pid ] && cat server.pid && break; sleep 0.1; done').strip()
    if not pid: raise RuntimeError("Server did not start / PID not captured.")
    return pid,port

def stop_world(name: str) -> None:
    _run(f'''
set -euo pipefail; base={bpath(name)}; pidfile="$base/server.pid"
stop(){{ p="$1"; [ -n "$p" ] && kill -0 "$p" 2>/dev/null && (kill "$p"||true; for i in $(seq 1 10); do kill -0 "$p" 2>/dev/null || break; sleep 1; done; kill -9 "$p" 2>/dev/null||true); }}
[ -f "$pidfile" ] && p="$(cat "$pidfile"||true)" && stop "$p" && rm -f "$pidfile"||true
world_real="$(readlink -f "$base")"
for p in $(pgrep -f "java"); do wd="$(readlink -f "/proc/$p/cwd" 2>/dev/null||true)"; wd="${{wd%% (deleted)}}"; [ "$wd" = "$world_real" ] && stop "$p"; done
''')

def world_pid(name: str) -> Optional[int]:
    out=_run(f'''
base={bpath(name)}; [ -f "$base/server.pid" ] && p="$(cat "$base/server.pid"||true)" && kill -0 "$p" 2>/dev/null && echo "$p" && exit 0
wr="$(readlink -f "$base")"; for p in $(pgrep -f "java"); do wd="$(readlink -f "/proc/$p/cwd" 2>/dev/null||true)"; wd="${{wd%% (deleted)}}"; [ "$wd" = "$wr" ] && echo "$p" && exit 0; done; echo ""
''').strip()
    try: return int(out) if out else None
    except Exception: return None

def is_listening(port: int) -> bool:
    try: return _run(f'timeout 1 bash -lc ": >/dev/tcp/127.0.0.1/{port} && echo yes || echo no"')=="yes"
    except Exception: return False

# ---- Console streaming (no flicker) ----
def read_console_chunk(name: str, offset: int, initial_bytes: int=16384) -> Tuple[str,int]:
    cmd = f'''
cd {bpath(name)} || exit 0; f="server.log"; size=$( [ -f "$f" ] && wc -c < "$f" || echo 0 ); off={int(offset)}; init={int(initial_bytes)}
if [ ! -f "$f" ]; then echo "__OFF__:$size"; exit 0; fi
if [ "$off" -le 0 ]; then
  if [ "$size" -gt "$init" ]; then tail -c "$init" "$f"; else cat "$f"; fi
else
  if [ "$size" -gt "$off" ]; then tail -c +$((off+1)) "$f"; fi
fi
echo
echo "__OFF__:$size"
'''
    out = _run(cmd).splitlines()
    if not out: return "", offset
    # last line contains the new size marker
    marker = out[-1] if out else "__OFF__:0"
    new_size = int(marker.split(":",1)[1]) if marker.startswith("__OFF__:") else offset
    chunk = "\n".join(out[:-1])
    return chunk, new_size

# ---- Fast multi-world summary (single SSH call) ----
def worlds_summary() -> List[Dict[str,object]]:
    out=_run(f'''
base="$HOME/{WORLDS_DIR}"; [ -d "$base" ] || exit 0
for d in "$base"/*; do
  [ -d "$d" ] || continue; name="$(basename "$d")"; pid=""
  [ -f "$d/server.pid" ] && p="$(cat "$d/server.pid" 2>/dev/null || true)" && kill -0 "$p" 2>/dev/null && pid="$p"
  if [ -z "$pid" ]; then
    wr="$(readlink -f "$d")"
    for p in $(pgrep -f "java"); do wd="$(readlink -f "/proc/$p/cwd" 2>/dev/null || true)"; wd="${{wd%% (deleted)}}"; [ "$wd" = "$wr" ] && pid="$p" && break; done
  fi
  port="$(grep -E "^server-port=" "$d/server.properties" 2>/dev/null | cut -d= -f2)"; [ -z "$port" ] && port="25565"
  echo "$name|$pid|$port"
done
''')
    items=[]
    for ln in [x for x in out.splitlines() if x]:
        name,pid,port=(ln.split("|")+["",""])[:3]
        items.append({"name":name,"running":bool(pid), "pid": int(pid) if pid else None, "port": int(port)})
    return items

# =====================================================================
#                 SSH TCP PROXY (dedicated loop thread)
# =====================================================================
class SSHBridgeHandler:
    def __init__(self, remote_port: int): self.remote_port=remote_port
    def _open(self, client_addr):
        c=_conn(); t=c.client.get_transport()  # type: ignore[attr-defined]
        if not t: raise RuntimeError("No SSH transport")
        dest=("127.0.0.1", int(self.remote_port)); src=((client_addr[0] if client_addr else "0.0.0.0"), int(client_addr[1] if client_addr else 0))
        chan=t.open_channel("direct-tcpip", dest, src); return c,chan
    async def run(self, r, w):
        peer=w.get_extra_info("peername") or ("0.0.0.0",0)
        try: conn,chan=await asyncio.to_thread(self._open, peer)
        except Exception: w.close(); await w.wait_closed(); return
        async def a2c():
            try:
                while True:
                    d=await asyncio.to_thread(chan.recv,65536)
                    if not d: break
                    w.write(d); await w.drain()
            finally:
                try: w.close(); await w.wait_closed()
                except Exception: pass
        async def c2a():
            try:
                while True:
                    d=await r.read(65536)
                    if not d: break
                    await asyncio.to_thread(chan.sendall,d)
            finally:
                try: chan.close()
                except Exception: pass
        await asyncio.gather(a2c(), c2a())

class ProxyManager:
    def __init__(self):
        self._map: Dict[str, Dict[str,object]] = {}  # world -> {server, port, remote_port}
        self._loop=asyncio.new_event_loop()
        threading.Thread(target=self._loop.run_forever, daemon=True).start()
    def info(self, world:str): return self._map.get(world)
    async def _find_port(self)->int:
        p=PROXY_PORT_START
        while True:
            with socket.socket(socket.AF_INET,socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
                try: s.bind((PROXY_BIND_HOST,p)); return p
                except OSError: p+=1
    async def _pub(self, world:str, remote_port:int)->int:
        if world in self._map:
            self._map[world]["remote_port"]=int(remote_port); return int(self._map[world]["port"])  # type: ignore[index]
        port=await self._find_port()
        async def handler(r,w, key=world):
            rp=int(self._map[key]["remote_port"])  # type: ignore[index]
            await SSHBridgeHandler(rp).run(r,w)
        server=await asyncio.start_server(handler, PROXY_BIND_HOST, port)
        self._map[world]={"server":server,"port":port,"remote_port":int(remote_port)}
        return port
    def publish(self, world:str, remote_port:int)->int:
        fut=asyncio.run_coroutine_threadsafe(self._pub(world,int(remote_port)), self._loop); return fut.result()
    async def _unpub(self, world:str)->bool:
        d=self._map.pop(world,None)
        if not d: return False
        s=d["server"]; s.close(); await s.wait_closed(); return True
    def unpublish(self, world:str)->bool:
        fut=asyncio.run_coroutine_threadsafe(self._unpub(world), self._loop); return fut.result()

proxy = ProxyManager()

# =====================================================================
#                                   API
# =====================================================================
@get("/dashblock/worlds", sync_to_thread=True)
def api_worlds()->dict:
    try:
        ensure_tree()
        items=worlds_summary()
        for it in items:
            info=proxy.info(it["name"])
            if info: it.update({"public_host": PUBLIC_HOST, "public_port": int(info["port"])})
        return {"ok":True, "worlds": items}
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@post("/dashblock/worlds", sync_to_thread=True)
def api_create(name:str)->dict:
    try:
        ensure_tree(); ensure_world(name)
        pub=proxy.publish(name, read_port(name))
        return {"ok":True, "created":name, "publish":{"public_host":PUBLIC_HOST,"public_port":pub}, "worlds": worlds_summary()}
    except HTTPException: raise
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@delete("/dashblock/worlds/{name:str}", sync_to_thread=True, status_code=200)
def api_delete(name:str)->dict:
    try:
        if not SAFE_NAME.fullmatch(name): raise HTTPException(400,"Invalid world name.")
        try: ensure_world(name); stop_world(name)
        except Exception: pass
        try: proxy.unpublish(name)
        except Exception: pass
        delete_world(name)
        return {"ok":True, "deleted":name, "worlds": worlds_summary()}
    except HTTPException: raise
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@get("/dashblock/worlds/{name:str}/details", sync_to_thread=True)
def api_details(name:str)->dict:
    try:
        if not SAFE_NAME.fullmatch(name): raise HTTPException(400,"Invalid world name.")
        ensure_world(name)
        cfg, mods, meta = read_props(name), list_mods(name), read_meta(name)
        info=proxy.info(name)
        publish={"active": bool(info), "public_host": PUBLIC_HOST if info else None, "public_port": int(info["port"]) if info else None, "remote_port": read_port(name)}
        return {"ok":True,"world":name,"config":cfg,"mods":mods,"meta":meta,"publish":publish}
    except HTTPException: raise
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@post("/dashblock/worlds/{name:str}/setup", sync_to_thread=True)
def api_setup(name:str, mc_version:str, mem_gb:int, motd:str="A Minecraft Server", online_mode:str|bool="true")->dict:
    try:
        if not SAFE_NAME.fullmatch(name): raise HTTPException(400,"Invalid world name.")
        ensure_world(name)
        meta=read_meta(name); full = meta.get("mc_version")!=mc_version
        info = setup_fabric(name, mc_version, int(mem_gb), motd, _parse_bool(online_mode)) if full else update_settings(name, int(mem_gb), motd, _parse_bool(online_mode))
        rp=read_port(name); pub=proxy.publish(name, rp)
        return {"ok":True,"world":name,"updated":("full" if full else "settings"),"setup":info,"config":read_props(name),"mods":list_mods(name),"meta":read_meta(name),
                "port":rp,"publish":{"active":True,"public_host":PUBLIC_HOST,"public_port":pub}}
    except HTTPException: raise
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@post("/dashblock/worlds/{name:str}/start", sync_to_thread=True)
def api_start(name:str)->dict:
    try:
        if not SAFE_NAME.fullmatch(name): raise HTTPException(400,"Invalid world name.")
        ensure_world(name); pid,port=start_world(name); pub=proxy.publish(name, port)
        return {"ok":True,"world":name,"pid":pid,"port":port,"publish":{"public_host":PUBLIC_HOST,"public_port":pub}}
    except HTTPException: raise
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@post("/dashblock/worlds/{name:str}/stop", sync_to_thread=True)
def api_stop(name:str)->dict:
    try:
        if not SAFE_NAME.fullmatch(name): raise HTTPException(400,"Invalid world name.")
        ensure_world(name); stop_world(name); return {"ok":True,"world":name}
    except HTTPException: raise
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@get("/dashblock/versions", sync_to_thread=True)
def api_versions()->dict:
    try: return {"ok":True, "versions": get_game_versions()}
    except Exception as e: raise HTTPException(502, f"Fetch versions error: {e}")

@get("/dashblock/worlds/{name:str}/status", sync_to_thread=True)
def api_status(name:str)->dict:
    try:
        ensure_world(name)
        p=read_port(name); pid=world_pid(name); info=proxy.info(name)
        return {"ok":True,"world":name,"ip":SSH_HOST,"port":p,"running":bool(pid),"pid":pid,"listening":is_listening(p),
                "publish":{"active":bool(info),"public_host":PUBLIC_HOST if info else None,"public_port":int(info["port"]) if info else None}}
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

@get("/dashblock/worlds/{name:str}/console", sync_to_thread=True)
def api_console(name:str, offset:int=0, initial_bytes:int=16384, tail:int=0)->dict:
    # If offset provided (default 0), stream incrementally; tail kept for legacy (ignored when offset used)
    try:
        ensure_world(name)
        chunk, new_off = read_console_chunk(name, offset=int(offset), initial_bytes=int(initial_bytes))
        return {"ok":True,"world":name,"offset":new_off,"chunk": chunk}
    except Exception as e: raise HTTPException(502, f"SSH error: {e}")

# ---- CORS & App ----
app = Litestar(
    route_handlers=[
        api_worlds, api_create, api_delete, api_details, api_setup,
        api_start, api_stop, api_versions, api_status, api_console
    ],
    cors_config=CORSConfig(allow_origins=["http://127.0.0.1:8001","http://localhost:8001"], allow_methods=["GET","POST","DELETE"], allow_headers=["*"]),
)
